// gcc main.c -L ./../../glfw/src -lglfw3 -framework OpenGL -framework Appkit -framework Cocoa -framework IOKit -framework CoreVideo && ./a.out

# define GLFW_INCLUDE_GLCOREARB

#include "../../glfw/include/GLFW/glfw3.h"
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SIZE_READ (4096*1)

int	ft_strlen(char *s)
{
	int	a;

	a = -1;
	while (++a && *s && s[a])
		;
	return a;
}

char	*strjoin(char *a, char *b)
{
	char	*s;
	int		i;
	int		lena;
	int		lenb;

	i = -1;
	s = NULL;
	if(!a && !(*b) )
		return (NULL);
	if (!a && *b)
	{
		lenb = strlen(b);
		s = (char *)malloc(sizeof(char)*lenb+1);
		i = -1;
		while (++i < lenb -1)
			s[i] = b[i];
		s[i+1] = '\0';
	}
	else
	{
		lenb = strlen(b);
		lena = strlen(a);
		s = (char *)malloc(sizeof(char)*( lena + lenb));
		i = -1;
		while (++i < lena -0)
			s[i] = a[i];
		i = -1;
		while (++i < lenb -1)
			s[i + lena-0] = b[i];
		s[i + lena] = '\0';
		if (a)
		{
			free(a);
			a = NULL;
		}
	}
	//printf("s == |%s|\na == |s|\nb == |s|\n", s);
	return (s);
}

typedef struct	s_env
{
	GLFWwindow* window;
	GLuint	vbo;
	GLuint	vao;
	GLuint	vs;
	GLuint	fs;
	GLuint shader_programme;
}				t_env;

const char	*g_vertex_shader =
"#version 410\n"
"in vec3 uv;"
"void main()"
"{"
	"gl_Position = vec4(uv, 1.0);"
"}"
;

const char	*g_fragment_shader =
"#version 410\n"
"out vec4 frag_colour;"
"void main() {"
"  frag_colour = vec4(0.5, 0.0, 0.5, 1.0);"
"}"
;

void	die(void)
{
	write(1, "!! die !!\n", 10);
	glfwTerminate();
}

typedef struct	s_vec3
{
	float	x;
	float	y;
	float	z;
}				t_vec3;

typedef struct	s_vertices
{
	t_vec3	point[3];
}				t_vertices;

typedef struct	s_faces
{
	int		*indexes;
	int		count;
}				t_faces;

int		mstrchr(char *s, int a)
{
	int	ret;

	ret = 0;
	while (s && *(s + ret) && *(s + ret) != (char)a )
		++ret;
	return (ret);
}

void	parse_file(char *obj_path)
{
	int		fd;
	char	*s;
	char	buff[SIZE_READ +1];
	int		count;

	count = 0;
	fd = open(obj_path, O_RDONLY);
	if (fd < 0)
		die();
	bzero(buff, '\0');
	s = NULL;
	while (read(fd, &buff, SIZE_READ))
	{
		s = strjoin(s, buff);
		memset(buff, '\0', SIZE_READ);
	}
	 printf("|%s| == s\n", s);
	 float	i;
	 int	off = 0;
	 off = 0;
	 printf("test chr\n");
	 //printf("mstrchr == %d\n", mstrchr(s+off, (int)'\n' ));
//	 while ( (off += mstrchr(s+off, (int)'\n' )) && (3 == sscanf(s+off, "v %f %f %f\n", &i, &i, &i) ) )
 // (3 == sscanf(s+off, "v %f %f %f\n", &i, &i, &i))
//	 	 printf("count vertices == %d, %s\n", count, s+off),++count;
//	 printf("count vertices == %d\n", count);
	 t_vertices	*vertices = (t_vertices *)malloc(sizeof(t_vertices)*count); 
}

static void	key_callback(GLFWwindow *window, int key, int scancode, int action, int mods)
{
	if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
		glfwSetWindowShouldClose(window, 1);
}

void	render(t_env *e)
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glUseProgram(e->shader_programme);
	glBindVertexArray(e->vao);
	glDrawArrays(GL_TRIANGLES, 0, 3);
	glfwPollEvents();
	glfwSwapBuffers(e->window);
}

void	compile_shaders(t_env *e)
{
	e->vs = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(e->vs, 1, &g_vertex_shader, NULL);
	glCompileShader(e->vs);
	e->fs = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(e->fs, 1, &g_fragment_shader, NULL);
	glCompileShader(e->fs);

	e->shader_programme = glCreateProgram();
	glAttachShader(e->shader_programme, e->fs);
	glAttachShader(e->shader_programme, e->vs);
	glLinkProgram(e->shader_programme);
}

#define OBJ_PATH "teapot.obj"

void	init_scop(t_env *e)
{
	float	**points;
	int		fd;
	int		num_faces;

	fd = open(OBJ_PATH, O_RDONLY);
	if (!fd)
		die();
	printf("before point\n");
	float faces[] = {-.0f, .50f, .0f, 
					.5f, -.5f, .0f,
					-.5f, -.50f, .0f
	};

	parse_file(OBJ_PATH);

	glGenBuffers(1, &(e->vbo));
	glBindBuffer(GL_ARRAY_BUFFER, e->vbo);
	glBufferData(GL_ARRAY_BUFFER, 9*sizeof(float), faces, GL_STATIC_DRAW);
	
	glGenVertexArrays(1, &(e->vao));
	glBindVertexArray(e->vao);
	glEnableVertexAttribArray(0);
	glBindBuffer(GL_ARRAY_BUFFER, e->vbo);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL);

	compile_shaders(e);
}

/*
**	To open a window on osx with glfw one MUST require a core profile
**	And set forward compatibiltity to true
*/

int		main(void)
{
	t_env	e;

	if (!glfwInit())
		write(1, "failed init !\n", 14);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	e.window = glfwCreateWindow(1920, 1440, "Scop", NULL, NULL);
	write(1, "test\n", 5);
	if (!e.window)
		die();
	glfwMakeContextCurrent(e.window);
	glfwSetKeyCallback(e.window, key_callback);
	init_scop(&e);
	while(!glfwWindowShouldClose(e.window) )
		render(&e);
	glfwDestroyWindow(e.window);
	die();
	return (0);
}
