// gcc main.c -L ./../../glfw/src -lglfw3 -framework OpenGL -framework Appkit -framework Cocoa -framework IOKit -framework CoreVideo && ./a.out

# define GLFW_INCLUDE_GLCOREARB

#include "../../glfw/include/GLFW/glfw3.h"
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct	s_env
{
	GLFWwindow* window;
	GLuint	vbo;
	GLuint	vao;
	GLuint	vs;
	GLuint	fs;
	GLuint shader_programme;
}				t_env;

const char	*g_vertex_shader =
"#version 410\n"
"in vec3 uv;"
"void main()"
"{"
	"gl_Position = vec4(uv, 1.0);"
"}"
;

const char	*g_fragment_shader =
"#version 410\n"
"out vec4 frag_colour;"
"void main() {"
"  frag_colour = vec4(0.5, 0.0, 0.5, 1.0);"
"}"
;

void	die(void)
{
	write(1, "!! die !!\n", 10);
	glfwTerminate();
}

static void	key_callback(GLFWwindow *window, int key, int scancode, int action, int mods)
{
	if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
		glfwSetWindowShouldClose(window, 1);
}

void	render(t_env *e)
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glUseProgram(e->shader_programme);
	glBindVertexArray(e->vao);
	glDrawArrays(GL_TRIANGLES, 0, 3);
	glfwPollEvents();
	glfwSwapBuffers(e->window);
}

void	compile_shaders(t_env *e)
{
	e->vs = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(e->vs, 1, &g_vertex_shader, NULL);
	glCompileShader(e->vs);
	e->fs = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(e->fs, 1, &g_fragment_shader, NULL);
	glCompileShader(e->fs);

	e->shader_programme = glCreateProgram();
	glAttachShader(e->shader_programme, e->fs);
	glAttachShader(e->shader_programme, e->vs);
	glLinkProgram(e->shader_programme);
}

/*
**	Open file, get_points_list, get_faces_list, close file
*/

char	*ft_strjoin_free_first_arg(char *latent, char *tmp)
{
	char	*ret;

	if (NULL == latent)
	{
		ret = (char*)malloc(sizeof(char)*strlen(tmp) );
		ret[0] = tmp[0];
		ret[1] = tmp[1];
	}
	else
	{
		ret = (char *)malloc(sizeof(char)*(strlen(latent) + strlen(tmp) ) );
		memcpy(ret, latent, strlen(latent) );
		printf("ret1 == \n", ret);
		memcpy(ret+strlen(latent), tmp, 2);
		printf("ret2 == \n", ret);
	}

	return (ret);
}

#define SIZE_READ 1

float	**append_tab(float **tab, float *entry, int len_tab, int count)
{
	float	**ret;
	int		i;
	int		j;

	ret = (float **)malloc(sizeof(float *) * 3 * (len_tab + 1));
	printf("entry == %f, len_tab == %d, %d \n", *entry, len_tab, count);
	ret[len_tab] = NULL;
	printf("before memcpy \n");
	i = -1;
	if (1 == len_tab)
	{
		printf("azaza \n");
		ret[0] = (float *)malloc(sizeof(float) * 3);
		j = -1;
		while (++j < count)
		{
			ret[0][j] = entry[j];
		}
	}
	else
	{
		if (tab == NULL)
			printf("argh \n");
		while(++i < len_tab - 1)
		{
			printf("i == %d,tab[i] == |%f| \n", i, tab[i][0]);
			ret[i] = (float *)malloc(sizeof(float) * (count) );
			j = -1;
			while (++j < count)
			{
				printf("axaxa\n");
				printf("tab[i][j] == %f, count == %d\n", tab[i][j], count);
				ret[i][j] = tab[i][j];
				printf("ret[i][j] == %f, count == %d\n", ret[i][j], count);
			}
			printf("L\n");
		}
		ret[len_tab] = (float *)malloc(sizeof(float) * (count) );
		i = -1;
		while (++i < count)
		{
			//printf("jajaja, len == %f\n", tab[len_tab-1][0]);
			printf("jajaja, entry == %f, i == %d, len_tab == %d\n", entry[i], i, len_tab);
			ret[len_tab ][i] = entry[i];
			printf("A\n");
		}

	}
	//memcpy(ret, tab, len_tab);
	printf("after memcpy \n");
	if (tab)
		free(tab);
	
	ret[len_tab + 2] = NULL;

	return (ret);
}

float	**get_points(int fd)
{
	float	**ret;
	float	point[3];
	char	tmp[SIZE_READ + 1];
	char	*latent;
	int		ret_num;

	tmp[SIZE_READ ] = '\0';
	latent = NULL;
	ret_num = 1;
	ret = NULL;
	while (read(fd, tmp, SIZE_READ) )
	{
		printf("while read point\n, %d", ret_num);
		latent = ft_strjoin_free_first_arg(latent, tmp);
		printf("join \n");
		if (latent[0] != 'v')
			break;
		if (tmp[0] == '\n')
		{
			printf("eol \n");
			printf("latent == |%s|, ret_num ==  %d\n", latent, ret_num);
			int r = sscanf(latent, "v %f %f %f \n", &point[0], &point[1], &point[2]);
			printf("r = %d || p[0] ==  %f || p[1] ==  %f || p[2] ==  %f\n", r, point[0],point[1],point[2]);
			ret = append_tab(ret, point, ret_num, 3);
			ret_num++;
			free(latent);
			latent = NULL;
		}
	}
	printf("end while point\n");
	free(latent);
	latent = NULL;
	return (ret);
}

float	**get_faces(float **points, int fd, int *num_faces)
{
	float	**ret;
	char	*latent;
	char	tmp[SIZE_READ + 1];
	float	face_tmp[4];
	int		face_count;
	int		ret_num;

	tmp[SIZE_READ] = '\0';
	latent = NULL;
	ret = NULL;
	face_count = 4;
	ret_num = 1;
	while (read(fd, tmp, SIZE_READ) )
	{
		latent = ft_strjoin_free_first_arg(latent, tmp);
		if (tmp[0] == '\n')
		{
			if (3 == sscanf(latent, "%f, %f, %f, %f", &face_tmp[0], &face_tmp[1], &face_tmp[2], &face_tmp[3]))
				face_count = 3;
			ret = append_tab(ret, face_tmp, ret_num, face_count);
			ret_num++;
		}
	}

	return (ret);
}

#define OBJ_PATH "teapot.obj"

void	init_scop(t_env *e)
{
	float	**points;
	float	**faces;
	int		fd;
	int		num_faces;

	fd = open(OBJ_PATH, O_RDONLY);
	if (!fd)
		die();
	printf("before point\n");
	points = get_points(fd);
//	faces = get_faces(points, fd, &num_faces);
	close(fd);
	glGenBuffers(1, &(e->vbo));
	glBindBuffer(GL_ARRAY_BUFFER, e->vbo);
	glBufferData(GL_ARRAY_BUFFER, 3 * num_faces * sizeof(float), faces, GL_STATIC_DRAW);
	
	glGenVertexArrays(1, &(e->vao));
	glBindVertexArray(e->vao);
	glEnableVertexAttribArray(0);
	glBindBuffer(GL_ARRAY_BUFFER, e->vbo);
	glVertexAttribPointer(0, num_faces, GL_FLOAT, GL_FALSE, 0, NULL);

	compile_shaders(e);
}

/*
**	To open a window on osx with glfw one MUST require a core profile
**	And set forward compatibiltity to true
*/

int		main(void)
{
	t_env	e;

	if (!glfwInit())
		write(1, "failed init !\n", 14);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	e.window = glfwCreateWindow(1920, 1440, "Scop", NULL, NULL);
	write(1, "test\n", 5);
	if (!e.window)
		die();
	glfwMakeContextCurrent(e.window);
	glfwSetKeyCallback(e.window, key_callback);
	init_scop(&e);
	while(!glfwWindowShouldClose(e.window) )
		render(&e);
	glfwDestroyWindow(e.window);
	die();
	return (0);
}
